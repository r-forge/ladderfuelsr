profile_list2$treeID <- factor(profile_list2$treeID)
# Tree metrics derived from get_distance() function
distance_metrics$treeID <- factor(distance_metrics$treeID)
metrics_depth_list <- list()
for (i in levels(profile_list2$treeID)){
tree1 <- profile_list2 |> dplyr::filter(treeID == i)
tree2 <- distance_metrics |> dplyr::filter(treeID == i)
# Get depths for each tree
metrics_depth <- get_depths(tree1, tree2)
metrics_depth_list[[i]] <- metrics_depth
}
# Combine the individual data frames
depth_metrics <- dplyr::bind_rows(metrics_depth_list)
depth_metrics <- depth_metrics[, order(names(depth_metrics))]
rownames(depth_metrics) <- NULL
head(depth_metrics)
library(LadderFuelsR)
library(ggplot2)
library(lattice)
# LAD profiles derived from normalized ALS data after applying [lad.profile()] function
profile_list2$treeID <- factor(profile_list2$treeID)
# Tree metrics derived from get_depths() function
depth_metrics$treeID <- factor(depth_metrics$treeID)
# Generate plots for gaps and fbhs
plots_gaps_fbhs <- get_plots_gap_fbh(profile_list2, depth_metrics)
par(mfrow = c(2, 2))
# Plot in RED are the GAPS and in GREEN the FBHs
plot(plots_gaps_fbhs[[1]])
plot(plots_gaps_fbhs[[2]])
plot(plots_gaps_fbhs[[3]])
library(SSBtools)
library(dplyr)
library(magrittr)
# Tree metrics derived from get_depths() function
depth_metrics$treeID <- factor(depth_metrics$treeID)
trees_name1 <- as.character(depth_metrics$treeID)
trees_name2 <- factor(unique(trees_name1))
fbh_corr_list <- list()
for (i in levels(trees_name2)){
# Filter data for each tree
tree3 <- depth_metrics |> dplyr::filter(treeID == i)
# Get real fbh for each tree
fbh_corr <- get_real_fbh(tree3)
# Store fbh values in a list
fbh_corr_list[[i]] <- fbh_corr
}
# Combine fbh values for all trees
fbh_metrics_corr <- dplyr::bind_rows(fbh_corr_list)
fbh_metrics_corr$treeID <- factor(fbh_metrics_corr$treeID)
# Reorder columns
# Get original column names
original_column_names <- colnames(fbh_metrics_corr)
# Specify prefixes
prefixes <- c("treeID", "Hdist", "Hcbh", "Hdepth", "dist", "depth", "max_height")
# Initialize vector to store new order
new_order <- c()
# Loop over prefixes
for (prefix in prefixes) {
# Find column names matching the current prefix
matching_columns <- grep(paste0("^", prefix), original_column_names, value = TRUE)
# Append to the new order
new_order <- c(new_order, matching_columns)
}
# Reorder values
fbh_metrics_corr <- fbh_metrics_corr[, new_order]
rownames(fbh_metrics_corr) <- NULL
head(fbh_metrics_corr)
library(dplyr)
library(magrittr)
library(tidyr)
# Tree metrics derived from get_real_fbh() function
fbh_metrics_corr$treeID <- factor(fbh_metrics_corr$treeID)
trees_name1 <- as.character(fbh_metrics_corr$treeID)
trees_name2 <- factor(unique(trees_name1))
depth_metrics_corr_list <- lapply(levels(trees_name2), function(i) {
# Filter data for each tree
tree2 <- fbh_metrics_corr |> dplyr::filter(treeID == i)
# Get real depths for each tree
get_real_depths(tree2)
})
# Combine depth values for all trees
depth_metrics_corr <- dplyr::bind_rows(depth_metrics_corr_list)
rownames(depth_metrics_corr) <- NULL
head(depth_metrics_corr)
library(dplyr)
library(magrittr)
library(stringr)
# Tree metrics derived from get_real_depths() function
depth_metrics_corr$treeID <- factor(depth_metrics_corr$treeID)
trees_name1 <- as.character(depth_metrics_corr$treeID)
trees_name2 <- factor(unique(trees_name1))
distance_metrics_corr_list <- lapply(levels(trees_name2), function(i) {
# Filter data for each tree
tree2 <- depth_metrics_corr |> dplyr::filter(treeID == i)
# Get effective gap for each tree
get_effective_gap(tree2)
})
# Combine the individual data frames
distances_metrics_corr <- dplyr::bind_rows(distance_metrics_corr_list)
# =======================================================================#
# REORDER COLUMNS:
# =======================================================================#
# Get original column names
original_column_names <- colnames(distances_metrics_corr)
# Specify prefixes
prefixes <- c("treeID", "Hcbh", "dptf", "Hdptf", "effdist", "dist", "Hdist", "max_Hcbh", "max_dptf", "max_Hdptf", "last_Hcbh", "last_dptf", "last_Hdptf", "max_height")
# Initialize vector to store new order
new_order <- c()
# Loop over prefixes
for (prefix in prefixes) {
# Find column names matching the current prefix
matching_columns <- grep(paste0("^", prefix), original_column_names, value = TRUE)
# Extract numeric suffixes and order the columns based on these suffixes
numeric_suffixes <- as.numeric(gsub(paste0("^", prefix), "", matching_columns))
matching_columns <- matching_columns[order(numeric_suffixes)]
# Append to new order
new_order <- c(new_order, matching_columns)
}
# Reorder values
distances_metrics_corr1 <- distances_metrics_corr[, new_order]
# Unlist the data frame
distances_metrics_corr2 <- as.data.frame(lapply(distances_metrics_corr1, function(x) unlist(x)))
rownames(distances_metrics_corr2) <- NULL
head(distances_metrics_corr2)
head(distances_metrics_corr2,6)
head(distances_metrics_corr2,10)
head(depth_metrics_corr)
head(fbh_metrics_corr)
head(depth_metrics)
head(distance_metrics)
head(gaps_perc,6)
library(dplyr)
library(magrittr)
# LAD profiles derived from normalized ALS data after applying [lad.profile()] function
profile_list2$treeID <- factor(profile_list2$treeID)
# Tree metrics derived from get_effective_gap() function
distances_metrics_corr2$treeID <- factor(distances_metrics_corr2$treeID)
trees_name1 <- as.character(distances_metrics_corr2$treeID)
trees_name2 <- factor(unique(trees_name1))
LAD_metrics1 <- list()
LAD_metrics2 <- list()
for (i in levels(trees_name2)) {
# Filter data for each tree
tree1 <- profile_list2 |> dplyr::filter(treeID == i)
tree2 <- distances_metrics_corr2 |> dplyr::filter(treeID == i)
# Get LAD metrics for each tree
LAD_metrics <- get_layers_lad(tree1, tree2, thrshold = 10)
LAD_metrics1[[i]] <- LAD_metrics$df1
LAD_metrics2[[i]] <- LAD_metrics$df2
}
library(dplyr)
library(magrittr)
# LAD profiles derived from normalized ALS data after applying [lad.profile()] function
profile_list2$treeID <- factor(profile_list2$treeID)
# Tree metrics derived from get_effective_gap() function
distances_metrics_corr2$treeID <- factor(distances_metrics_corr2$treeID)
trees_name1 <- as.character(distances_metrics_corr2$treeID)
trees_name2 <- factor(unique(trees_name1))
LAD_metrics1 <- list()
LAD_metrics2 <- list()
for (i in levels(trees_name2)) {
# Filter data for each tree
tree1 <- profile_list2 |> dplyr::filter(treeID == i)
tree2 <- distances_metrics_corr2 |> dplyr::filter(treeID == i)
# Get LAD metrics for each tree
LAD_metrics <- get_layers_lad(tree1, tree2, threshold = 10)
LAD_metrics1[[i]] <- LAD_metrics$df1
LAD_metrics2[[i]] <- LAD_metrics$df2
}
LAD_metrics_all1 <- dplyr::bind_rows(LAD_metrics1)
LAD_metrics_all2 <- dplyr::bind_rows(LAD_metrics2)
# List of data frames
LAD_metrics_list <- list(LAD_metrics_all1, LAD_metrics_all2)
# Initialize an empty list to store reordered data frames
fuels_LAD_metrics <- list()
# Specify prefixes (adjust accordingly)
prefixes <- c("treeID", "Hdist", "Hcbh", "effdist", "dptf", "Hdptf", "max", "last")
# Loop over each data frame
for (i in seq_along(LAD_metrics_list)) {
LAD_metrics_all <- LAD_metrics_list[[i]]
# Get original column names
original_column_names <- colnames(LAD_metrics_all)
# Initialize vector to store new order
new_order <- c()
# Loop over prefixes
for (prefix in prefixes) {
# Find column names matching the current prefix
matching_columns <- grep(paste0("^", prefix), original_column_names, value = TRUE)
# Extract numeric suffixes and order the columns based on these suffixes
numeric_suffixes <- as.numeric(gsub(paste0("^", prefix), "", matching_columns))
# Order the columns based on numeric suffixes
matching_columns <- matching_columns[order(numeric_suffixes)]
# Append to new order
new_order <- c(new_order, matching_columns)
}
# Reorder columns
LAD_metrics_all <- LAD_metrics_all[, new_order]
# Store the reordered data frame in the list
fuels_LAD_metrics[[i]] <- LAD_metrics_all
}
rownames(fuels_LAD_metrics[[1]]) <- NULL
rownames(fuels_LAD_metrics[[2]]) <- NULL
head(fuels_LAD_metrics[[2]])
library(ggplot2)
# LAD profiles derived from normalized ALS data after applying [lad.profile()] function
profile_list2$treeID <- factor(profile_list2$treeID)
# Tree metrics derived from get_layers_lad() function
LAD_gt10p <- fuels_LAD_metrics[[2]]
trees_name1 <- as.character(LAD_gt10p$treeID)
trees_name2 <- factor(unique(trees_name1))
# Generate plots for fuels LAD metrics
plots_trees_LAD <- get_plots_cbh_LAD(profile_list2, LAD_gt10p)
plot(plots_trees_LAD[[1]])
LAD_gt10p
plots_trees_LAD <- get_plots_effective(profile_list2, LAD_gt10p)
plot(plots_trees_LAD[[1]])
plot(plots_trees_LAD[[1]])
plot(plots_trees_LAD[[2]])
plot(plots_trees_LAD[[3]])
library(dplyr)
library(magrittr)
# Tree metrics derived from get_layers_lad() function
LAD_gt10p <- fuels_LAD_metrics[[2]]
trees_name1 <- as.character(LAD_gt10p$treeID)
trees_name2 <- factor(unique(trees_name1))
cbh_metrics_list <- list()
for (j in levels(trees_name2)){
# Filter data for each tree
tree1 <- LAD_gt10p |> dplyr::filter(treeID == j)
cbh_metrics <- get_cbh_metrics(tree1)
cbh_metrics_list[[j]] <- cbh_metrics
}
# Combine depth values for all trees
cbh_metrics_all <- dplyr::bind_rows(cbh_metrics_list)
# Get original column names
original_column_names <- colnames(cbh_metrics_all)
# Specify prefixes
desired_order <- c("treeID", "Hcbh", "dptf","effdist","dist", "Hdist", "Hdptf","maxlad_","max_","last_","nlayers")
# Identify unique prefixes
prefixes <- unique(sub("^([a-zA-Z]+).*", "\\1", original_column_names))
# Initialize vector to store new order
new_order <- c()
# Loop over desired order of prefixes
for (prefix in desired_order) {
# Find column names matching the current prefix
matching_columns <- grep(paste0("^", prefix), original_column_names, value = TRUE)
# Append to the new order
new_order <- c(new_order, matching_columns)
}
# Reorder columns
cbh_metrics_all <- cbh_metrics_all[, new_order]
cbh_metrics_all
library(ggplot2)
# LAD profiles derived from normalized ALS data after applying [lad.profile()] function
profile_list2$treeID <- factor(profile_list2$treeID)
# Tree metrics derived from get_cbh_metrics() function
cbh_metrics_all <- factor(cbh_metrics_all$treeID)
trees_name1 <- as.character(cbh_metrics_all$treeID)
# LAD profiles derived from normalized ALS data after applying [lad.profile()] function
profile_list2$treeID <- factor(profile_list2$treeID)
# Tree metrics derived from get_cbh_metrics() function
cbh_metrics_all$treeID <- factor(cbh_metrics_all$treeID)
cbh_metrics_all
# Tree metrics derived from get_layers_lad() function
LAD_gt10p <- fuels_LAD_metrics[[2]]
trees_name1 <- as.character(LAD_gt10p$treeID)
trees_name2 <- factor(unique(trees_name1))
cbh_metrics_list <- list()
for (j in levels(trees_name2)){
# Filter data for each tree
tree1 <- LAD_gt10p |> dplyr::filter(treeID == j)
cbh_metrics <- get_cbh_metrics(tree1)
cbh_metrics_list[[j]] <- cbh_metrics
}
# Combine depth values for all trees
cbh_metrics_all <- dplyr::bind_rows(cbh_metrics_list)
# Get original column names
original_column_names <- colnames(cbh_metrics_all)
# Specify prefixes
desired_order <- c("treeID", "Hcbh", "dptf","effdist","dist", "Hdist", "Hdptf","maxlad_","max_","last_","nlayers")
# Identify unique prefixes
prefixes <- unique(sub("^([a-zA-Z]+).*", "\\1", original_column_names))
# Initialize vector to store new order
new_order <- c()
# Loop over desired order of prefixes
for (prefix in desired_order) {
# Find column names matching the current prefix
matching_columns <- grep(paste0("^", prefix), original_column_names, value = TRUE)
# Append to the new order
new_order <- c(new_order, matching_columns)
}
# Reorder columns
cbh_metrics_all <- cbh_metrics_all[, new_order]
cbh_metrics_all
library(ggplot2)
# LAD profiles derived from normalized ALS data after applying [lad.profile()] function
profile_list2$treeID <- factor(profile_list2$treeID)
# Tree metrics derived from get_cbh_metrics() function
cbh_metrics_all$treeID <- factor(cbh_metrics_all$treeID)
trees_name1 <- as.character(cbh_metrics_all$treeID)
trees_name2 <- factor(unique(trees_name1))
# Generate plots for fuels LAD metrics
plots_cbh_maxlad <- get_plots_cbh_LAD(profile_list2, cbh_metrics_all)
plots_cbh_maxdist <- get_plots_cbh_maxdist(profile_list2, cbh_metrics_all)
plots_cbh_lastdist <- get_plots_cbh_lastdist(profile_list2, cbh_metrics_all)
plot(plots_cbh_maxlad[[1]])
plot(plots_cbh_maxdist[[1]])
plot(plots_cbh_lastdist[[1]])
plot(plots_cbh_maxlad[[2]])
plot(plots_cbh_maxdist[[2]])
plot(plots_cbh_lastdist[[2]])
plot(plots_cbh_maxlad[[3]])
plot(plots_cbh_maxdist[[3]])
plot(plots_cbh_lastdist[[3]])
plot(plots_cbh_maxlad[[1]])
plot(plots_cbh_maxdist[[1]])
plot(plots_cbh_lastdist[[1]])
library(dplyr)
library(magrittr)
# LAD profiles derived from normalized ALS data after applying [lad.profile()] function
profile_list2$treeID <- factor(profile_list2$treeID)
# Tree metrics derived from get_cbh_metrics() function
cbh_metrics_all$treeID <- factor(cbh_metrics_all$treeID)
trees_name1 <- as.character(cbh_metrics_all$treeID)
trees_name2 <- factor(unique(trees_name1))
cum_LAD_metrics_list <- list()
for (i in levels(trees_name2)) {
# Filter data for each tree
tree1 <- profile_list2 |> dplyr::filter(treeID == i)
tree2 <- cbh_metrics_all |> dplyr::filter(treeID == i)
# Get cumulative LAD metrics for each tree
cum_LAD_metrics_all <- get_cum_break(tree1, tree2)
cum_LAD_metrics_list[[i]] <- cum_LAD_metrics_all
}
# Combine the individual data frames
cum_LAD_metrics <- dplyr::bind_rows(cum_LAD_metrics_list)
# =======================================================================#
# REORDER COLUMNS
# =======================================================================#
# Get original column names
original_column_names <- colnames(cum_LAD_metrics)
# Specify prefixes (adjust accordingly)
prefixes <- c("treeID", "Hcbh", "below", "above", "depth", "Hdepth", "dptf", "Hdptf", "Hdist", "effdist", "max", "last", "cumlad")
# Initialize vector to store new order
new_order <- c()
# Loop over prefixes
for (prefix in prefixes) {
# Find column names matching the current prefix
matching_columns <- grep(paste0("^", prefix), original_column_names, value = TRUE)
# Extract numeric suffixes and order the columns based on these suffixes
numeric_suffixes <- as.numeric(gsub(paste0("^", prefix), "", matching_columns))
matching_columns <- matching_columns[order(numeric_suffixes)]
# Append to new order
new_order <- c(new_order, matching_columns)
}
# Reorder columns
cum_LAD_metrics <- cum_LAD_metrics[, new_order]
## when % LAD is < 75 % below or above the BP (Breaking Point), Hcbh1 is derived from CBH maximum LAD criterium
rownames(cum_LAD_metrics) <- NULL
head(cum_LAD_metrics)
library(ggplot2)
# LAD profiles derived from normalized ALS data after applying [lad.profile()] function
profile_list2$treeID <- factor(profile_list2$treeID)
# Tree metrics derived from get_cum_break() function
cum_LAD_metrics$treeID <- factor(cum_LAD_metrics$treeID)
# Generate plots
plots_cbh_bp <- get_plots_cbh_bp(profile_list2, cum_LAD_metrics)
plot(plots_cbh_bp[[1]])
library(dplyr)
library(magrittr)
# LAD profiles derived from normalized ALS data after applying [lad.profile()] function
profile_list2$treeID <- factor(profile_list2$treeID)
# Tree metrics derived from get_cbh_metrics() function
cbh_metrics_all$treeID <- factor(cbh_metrics_all$treeID)
trees_name1 <- as.character(cbh_metrics_all$treeID)
trees_name2 <- factor(unique(trees_name1))
cum_LAD_metrics_list <- list()
for (i in levels(trees_name2)) {
# Filter data for each tree
tree1 <- profile_list2 |> dplyr::filter(treeID == i)
tree2 <- cbh_metrics_all |> dplyr::filter(treeID == i)
# Get cumulative LAD metrics for each tree
cum_LAD_metrics_all <- get_cum_break(tree1, tree2,threshold=75, verbose=TRUE)
cum_LAD_metrics_list[[i]] <- cum_LAD_metrics_all
}
# Combine the individual data frames
cum_LAD_metrics <- dplyr::bind_rows(cum_LAD_metrics_list)
cum_LAD_metrics
# Get original column names
original_column_names <- colnames(cum_LAD_metrics)
# Specify prefixes (adjust accordingly)
prefixes <- c("treeID", "Hcbh", "below", "above", "bp", "max", "cumlad")
# Initialize vector to store new order
new_order <- c()
# Loop over prefixes
for (prefix in prefixes) {
# Find column names matching the current prefix
matching_columns <- grep(paste0("^", prefix), original_column_names, value = TRUE)
# Extract numeric suffixes and order the columns based on these suffixes
numeric_suffixes <- as.numeric(gsub(paste0("^", prefix), "", matching_columns))
matching_columns <- matching_columns[order(numeric_suffixes)]
# Append to new order
new_order <- c(new_order, matching_columns)
}
# Reorder columns
cum_LAD_metrics <- cum_LAD_metrics[, new_order]
## when % LAD is < 75 % below or above the BP (Breaking Point), Hcbh1 is derived from CBH maximum LAD criterium
rownames(cum_LAD_metrics) <- NULL
head(cum_LAD_metrics)
library(ggplot2)
# LAD profiles derived from normalized ALS data after applying [lad.profile()] function
profile_list2$treeID <- factor(profile_list2$treeID)
# Tree metrics derived from get_cum_break() function
cum_LAD_metrics$treeID <- factor(cum_LAD_metrics$treeID)
# Generate plots
plots_cbh_bp <- get_plots_cbh_bp(profile_list2, cum_LAD_metrics)
plot(plots_cbh_bp[[1]])
plot(plots_cbh_bp[[2]])
plot(plots_cbh_bp[[3]])
LAD_gt10p <- fuels_LAD_metrics[[2]]
LAD_gt10p$treeID1 <- factor(LAD_gt10p$treeID1)
# crown polygons (output from step 4)
tree_crowns$treeID1 <- factor(tree_crowns$treeID)
LIDAR_dir <- file.path(system.file("extdata", package = "LadderFuelsR"))
lidar_file<- lidR::readLAS(file.path(LIDAR_dir, "Eglin_zone1_clipped_000000.las"), filter = "-drop_z_below 0")
chm_pitfree<- grid_canopy(lidar_file, res=0.5,pitfree( c(0,2,5,10,15,20,25,30,35,40), c(0,1.5), subcircle=0.15))
chm_pitfree[chm_pitfree > 40] <- NA
chm_pitfree[chm_pitfree < 0] <- 0
chm_pitfree1 <- projectRaster(chm_pitfree, crs=26916)
# parameters
ws= 2.5
hmin = 2
res=0.5
ttops_multichm = find_trees(lidar_file, multichm(res = res, dist_2d = 2,ws= ws, layer_thickness = 0.3,dist_3d = 1, hmin = hmin))
proj4string(ttops_multichm) <- CRS('+init=EPSG:26916')
# Create an rgl point cloud
x<-add_treetops3d(plot(lidar_file, bg = "white", size = 4), ttops_multichm)
# Customize the plot orientation
rgl.viewpoint(theta = 0, phi = 0, fov = 60, zoom = 0.75)
# Convert the rgl scene to an HTML widget
rglwidget(elementId = "x", width = 800, height = 600)
algo_silva1 <-silva2016(chm_pitfree1, ttops_multichm, max_cr_factor = 0.6, exclusion = 0.3, ID = "treeID")
crowns_silva_las1 <-segment_trees(lidar_file, algo_silva1, attribute = "treeID", uniqueness = "incremental")
crowns_silva_las2<-filter_poi(crowns_silva_las1, !is.na(treeID))
my_palette <- colorRampPalette(col)
algo_silva1 <-silva2016(chm_pitfree1, ttops_multichm, max_cr_factor = 0.6, exclusion = 0.3, ID = "treeID")
crowns_silva_las1 <-segment_trees(lidar_file, algo_silva1, attribute = "treeID", uniqueness = "incremental")
crowns_silva_las2<-filter_poi(crowns_silva_las1, !is.na(treeID))
custom_crown_metrics <- function(z, i) { # user-defined function
metrics <- list(
dz = 1,
th = 1,
z_max = max(z),# max height
z_min = min(z),# min height
z_mean = mean(z),# mean height
z_sd = sd(z), # vertical variability of points
z_q1=quantile(z, probs = 0.01),
z_q5=quantile(z, probs = 0.05),
z_q25=quantile(z, probs = 0.25),
z_q50=quantile(z, probs = 0.50),
z_q75=quantile(z, probs = 0.75),
z_q95=quantile(z, probs = 0.95),
crr=(mean(z)-min(z))/(max(z)-min(z))
)
return(metrics) # output
}
ccm = ~custom_crown_metrics(z = Z, i = Intensity)
crowns_silva_filter<-filter_poi(crowns_silva_las2, Z >= 1)
metrics1 = crown_metrics(crowns_silva_filter,func = .stdtreemetrics, geom = "convex")
crown_diam<-data.frame(sqrt(metrics1$convhull_area/ pi) * 2)
names(crown_diam)<-"crown_diam"
metrics2 = crown_metrics(crowns_silva_filter,func = ccm, geom = "convex") #concave
metrics_all <- dplyr::bind_cols(list(metrics1,crown_diam,metrics2))
metrics_all1 <- metrics_all[,c(1:4,6,10:21)]
names(metrics_all1)<-c("treeID", "Z", "npoints", "convhull_area", "crown_diam", "z_max", "z_min", "z_mean","z_sd", "z_q1","z_q5", "z_q25","z_q50","z_q75", "z_q95", "crr", "geometry" )
tree_crowns <- st_as_sf(metrics_all1)
ttops1<-st_as_sf(ttops_multichm)
crowns1<-st_as_sf(tree_crowns)
ttops_within_crowns <- st_intersection(ttops1, crowns1)
tree_crowns
LAD_gt10p <- fuels_LAD_metrics[[2]]
LAD_gt10p$treeID1 <- factor(LAD_gt10p$treeID1)
# crown polygons (output from step 4)
tree_crowns$treeID1 <- factor(tree_crowns$treeID)
crowns_properties<-merge (tree_crowns,LAD_gt10p, by="treeID1")
crowns_properties$maxlad_Hcbh_factor <- cut(crowns_properties$maxlad_Hcbh, breaks = 5)
crowns_properties
cbh_metrics_all$treeID1 <- factor(cbh_metrics_all$treeID1)
# crown polygons (output from step 4)
tree_crowns$treeID1 <- factor(tree_crowns$treeID)
crowns_properties<-merge (tree_crowns,cbh_metrics_all, by="treeID1")
crowns_properties
crowns_properties$maxlad_Hcbh_factor <- cut(crowns_properties$maxlad_Hcbh, breaks = 5)
# Plotting with a discrete legend
palette <- colorRampPalette(c("orange", "dark green"))
ggplot() +
geom_sf(data = crowns_properties, aes(fill = maxlad_Hcbh_factor)) +
scale_fill_manual(values = palette(5)) +
theme_minimal() +
labs(title = "Tree Crowns", fill = "maxlad_Hcbh")
LAD_dir <- "GREDOS_FMs/3.CHM/CROWNS/WATER_LAI/ZONES"
LAD_folders <- list.dirs(LAD_dir, full.names = TRUE, recursive = FALSE)
LAD_list <- list.files(LAD_folders, pattern =  glob2rx("LAD_profiles_*.txt"), full.names = TRUE, ignore.case = TRUE)
roxygen2::roxygenise()
library(LadderFuelsR)
roxygen2::roxygenise()
library(LadderFuelsR)
roxygen2::roxygenise()
roxygen2::roxygenise()
library(LadderFuelsR)
roxygen2::roxygenise()
roxygen2::roxygenise()
